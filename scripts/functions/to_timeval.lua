-- Hardcoded tables generated by make_pitches.lua and make_rhythms.lua
local PITCHES = require("functions/pitches")
local RHYTHMS = require("functions/rhythms")

local MOD_ERROR = "[Shell Bell Music]: "
local ERROR_MSG = "For song file '%s', we failed to convert %s \"%s\"!"..
"\nIt has %s \"%s\" located at data.notes index %d."

local function printf(fmt, ...)
    print(MOD_ERROR.. string.format(fmt, ...))
end

local function FailWarning(title, typeof1, val1, typeof2, val2, index)
    if type(val1) ~= "string" then
        val1 = tostring(val1)
    end
    -- Evaluate separately in case both aren't strings
    if type(val2) ~= "string" then
        val2 = tostring(val2)
    end

    typeof1 = typeof1.." value"
    typeof2 = typeof2.." value"

    printf(ERROR_MSG, title, typeof1, val1, typeof2, val2, index)
end

local function InvalidTime(title, out_time, out_pitch, index)
    FailWarning(title, "time", out_time, "pitch", out_pitch, index)
end

local function InvalidPitch(title, out_pitch, out_time, index)
    FailWarning(title, "pitch", out_pitch, "time", out_time, index)
end

-- `ref_tbl` is either PITCHES or RHYTHMS from above.
local function EvaluateVal(val, ref_tbl)
    if type(val) == "string" then
        val = ref_tbl[val]
        -- If ref_tbl[val] returned nil, it was invalid
        if not val then
            return nil
        end
    elseif type(val) ~= "number" then
        return nil
    end
    -- Will also pass if val was a number to begin with
    return val
end

-- Modify song table directly.
local function ConvertVals(mainfn, beat_num, note_tbl, error_count)    
    -- note_tbl[1] and note_tbl.t *should* be constant keys, so don't loop

    -- `in` stands for `input`
    local in_pitch = note_tbl[1]
    local in_time = note_tbl.t

    -- `out` stands for `output`
    local out_pitch = EvaluateVal(in_pitch, PITCHES)
    local out_time = EvaluateVal(in_time, RHYTHMS)

    if not out_pitch then
        --[[ Force return so we don't mess up anything else,
        But keep going for the rest of the songfile.
        This is so we can document all possible errors. ]]
        error_count = error_count + 1
        InvalidPitch(mainfn.title, in_pitch, in_time, beat_num)
        return 
    elseif not out_time then
        InvalidTime(mainfn.title, in_time, in_pitch, beat_num)
        error_count = error_count + 1
        return 
    end
    
    if out_pitch == 0 then
        mainfn.offset = mainfn.offset + out_time
        --[[ Update offset only and ignore the note_tbl. 
        TODO: Erase or ignore this note table without messing up the rest. ]]
        return 
    end
    
    local new_pitch = out_pitch + mainfn.transpose
    local new_time = mainfn.offset
    table.insert(mainfn.notes, { [1] = new_pitch, ["t"] = new_time })

    --[[ Update mainfn.offset AFTER we set the song[index].t value
    This is so we effectively get the offset of the PREVIOUS note.
    THEN we update the offset. This is weird, but it works. ]]
    mainfn.offset = mainfn.offset + out_time
end

local got_error = "Warning! We got %d errors while compiling song file '%s'."
function TimeVal(title, song, transpose)
    local mainfn = {
        -- Constant Values
        title = title,
        transpose = transpose or 0,
        -- Final table we'll return
        notes = {},
        -- offset starts at 0 game distance units, modify it as we go.
        offset = 0,
    }

    local error_count = 0
    for i, note_tbl in ipairs(song) do
        ConvertVals(mainfn, i, note_tbl, error_count)
    end

    if error_count > 0 then
        -- Don't insert an invalid song table
        printf(got_error, error_count, title)
        return nil
    end

    return mainfn.notes
end

return TimeVal
